---
layout: post
title:  "BFS"
tags: bfs
---
## Template

### Queue

[Cheapest Flights Within K Stops][cheapest-flights-within-k-stops]

{% highlight java %}
private int MAX = 100 * (100 - 1) / 2 * 10000 + 1;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    // buils graph
    Map<Integer, List<int[]>> graph = new HashMap<>();
    for (int[] f : flights) {
        graph.computeIfAbsent(f[0], k -> new ArrayList<>()).add(new int[]{f[1], f[2]});
    }

    // BFS
    Queue<int[]> q = new LinkedList<>();
    int[] node = {src, 0};  // city, price
    q.offer(node);

    int stop = -1, min = MAX;
    while (!q.isEmpty() && stop <= K) {
        // level traversal
        for (int i = q.size(); i > 0; i--) {
            node = q.poll();

            if (node[0] == dst) {
                min = Math.min(min, node[1]);
            }

            if (stop == K || !graph.containsKey(node[0])) {
                continue;
            }

            for (int[] pair : graph.get(node[0])) {
                int neighbor = pair[0], price = pair[1];

                // pruning
                if (node[1] + price > min) {
                    continue;
                }

                // adds city:price pair.
                // some pairs may have the same city due to different paths
                q.offer(new int[]{neighbor, node[1] + price});
            }
        }

        stop++;
    }

    return min == MAX ? -1 : min;
}
{% endhighlight %}

[Jump Game II][jump-game-ii]

{% highlight java %}
public int jump(int[] nums) {
    // implicit BFS
    int jump = 0, reach = 0, currEnd = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        reach = Math.max(reach, i + nums[i]);

        // all the nodes on the current level are visited
        if (i == currEnd) {
            // increments level
            // nodes on the next level can be reached with this number of jumps
            jump++;
            // gets next level size
            currEnd = reach;
        }
    }
    return jump;
}
{% endhighlight %}

If it's not guaranteed to reach the last index:

{% highlight java %}
public int jump(int[] nums) {
    // implicit BFS
    int jumps = 0, reach = 0, currEnd = 0;
    for (int i = 0; i < nums.length; i++) {
        if (i > reach) {
            return -1;
        }

        reach = Math.max(reach, i + nums[i]);

        // all the nodes on the current level are visited
        if (i < nums.length - 1 && i == currEnd) {
            // increments level
            // nodes on the next level can be reached with this number of jumps
            jumps++;
            // gets next level size
            currEnd = reach;
        }
    }
    return jumps;
}
{% endhighlight %}

[Nested List Weight Sum II][nested-list-weight-sum-ii]

{% highlight java %}
public int depthSumInverse(List<NestedInteger> nestedList) {
    Queue<NestedInteger> q = new LinkedList(nestedList);
    int runningSum = 0, sum = 0;
    while (!q.isEmpty()) {
       int size = q.size();
       for (int i = 0; i < size; i++) {
           NestedInteger ni = q.poll();
           if (ni.isInteger()) {
               runningSum += ni.getInteger();
           } else {
               q.addAll(ni.getList());
           }
       }
       sum += runningSum;
    }
    return sum;
}
{% endhighlight %}

[Walls and Gates][walls-and-gates]

{% highlight java %}
{% raw %}
private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
{% endraw %}
public void wallsAndGates(int[][] rooms) {
    Queue<int[]> q = new LinkedList<>();
    for (int i = 0; i < rooms.length; i++) {
        for (int j = 0; j < rooms[i].length; j++) {
            if (rooms[i][j] == 0) {
                q.offer(new int[]{i, j});
            }
        }
    }

    while (!q.isEmpty()) {
        int[] p = q.poll();
        int r = p[0], c = p[1];
        for (int[] d : DIRECTIONS) {
            int i = r + d[0], j = c + d[1];
            if (i < 0 || i >= rooms.length || j < 0 || j >= rooms[i].length || rooms[i][j] != Integer.MAX_VALUE) {
                continue;
            }

            // each gate only checks the areas within 1 space
            // so whenever an empty room is reached, it must be from the closest gate
            rooms[i][j] = rooms[r][c] + 1;
            q.offer(new int[] {i, j});
        }
    }
}
{% endhighlight %}

[cheapest-flights-within-k-stops]: https://leetcode.com/problems/cheapest-flights-within-k-stops/
[jump-game-ii]: https://leetcode.com/problems/jump-game-ii/
[nested-list-weight-sum-ii]: https://leetcode.com/problems/nested-list-weight-sum-ii/
[walls-and-gates]: https://leetcode.com/problems/walls-and-gates/
