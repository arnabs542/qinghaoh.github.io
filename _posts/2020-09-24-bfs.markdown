---
layout: post
title:  "BFS"
tags: bfs
---
## Template

### Queue

[Cheapest Flights Within K Stops][cheapest-flights-within-k-stops]

{% highlight java %}
private int MAX = 100 * (100 - 1) / 2 * 10000 + 1;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    // buils graph
    Map<Integer, List<int[]>> graph = new HashMap<>();
    for (int[] f : flights) {
        graph.computeIfAbsent(f[0], k -> new ArrayList<>()).add(new int[]{f[1], f[2]});
    }

    // BFS
    Queue<int[]> q = new LinkedList<>();
    int[] node = {src, 0};  // city, price
    q.offer(node);

    int stop = -1, min = MAX;
    while (!q.isEmpty() && stop <= K) {
        // level traversal
        int size = q.size();
        for (int i = 0; i < size; i++) {
            node = q.poll();

            if (node[0] == dst) {
                min = Math.min(min, node[1]);
            }

            if (stop == K || !graph.containsKey(node[0])) {
                continue;
            }

            for (int[] pair : graph.get(node[0])) {
                int neighbor = pair[0], price = pair[1];

                // pruning
                if (node[1] + price > min) {
                    continue;
                }

                // adds city:price pair.
                // some pairs may have the same city due to different paths
                q.offer(new int[]{neighbor, node[1] + price});
            }
        }

        stop++;
    }

    return min == MAX ? -1 : min;
}
{% endhighlight %}

[Jump Game II][jump-game-ii]

{% highlight java %}
public int jump(int[] nums) {
    // implicit BFS
    int jump = 0, reach = 0, currEnd = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        reach = Math.max(reach, i + nums[i]);

        // all the nodes on the current level are visited
        if (i == currEnd) {
            // increments level
            // nodes on the next level can be reached with this number of jumps
            jump++;
            // gets next level size
            currEnd = reach;
        }
    }
    return jump;
}
{% endhighlight %}

If it's not guaranteed to reach the last index:

{% highlight java %}
public int jump(int[] nums) {
    // implicit BFS
    int jumps = 0, reach = 0, currEnd = 0;
    for (int i = 0; i < nums.length; i++) {
        if (i > reach) {
            return -1;
        }

        reach = Math.max(reach, i + nums[i]);

        // all the nodes on the current level are visited
        if (i < nums.length - 1 && i == currEnd) {
            // increments level
            // nodes on the next level can be reached with this number of jumps
            jumps++;
            // gets next level size
            currEnd = reach;
        }
    }
    return jumps;
}
{% endhighlight %}

[Nested List Weight Sum II][nested-list-weight-sum-ii]

{% highlight java %}
public int depthSumInverse(List<NestedInteger> nestedList) {
    Queue<NestedInteger> q = new LinkedList(nestedList);
    int runningSum = 0, sum = 0;
    while (!q.isEmpty()) {
       int size = q.size();
       for (int i = 0; i < size; i++) {
           NestedInteger ni = q.poll();
           if (ni.isInteger()) {
               runningSum += ni.getInteger();
           } else {
               q.addAll(ni.getList());
           }
       }
       sum += runningSum;
    }
    return sum;
}
{% endhighlight %}

[cheapest-flights-within-k-stops]: https://leetcode.com/problems/cheapest-flights-within-k-stops/
[jump-game-ii]: https://leetcode.com/problems/jump-game-ii/
[nested-list-weight-sum-ii]: https://leetcode.com/problems/nested-list-weight-sum-ii/
