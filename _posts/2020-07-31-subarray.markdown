---
layout: post
title:  "Subarray"
tags: array
---
# Definition
```
a[i], a[i + 1], ..., a[j]
```
Where `0 <= i <= j <= a.length`

# Algorithm

## Prefix Sum

[Subarray Sum Equals K][subarray-sum-equals-k]

{% highlight java %}
public int subarraySum(int[] nums, int k) {
    int sum = 0, count = 0;
    Map<Integer, Integer> map = new HashMap<>();  // prefix sum : count
    for (int num : nums) {
        sum += num;
        if (sum == k) {
            count++;
        }

        if (map.containsKey(sum - k)) {
            count += map.get(sum - k);
        }

        map.put(sum, map.getOrDefault(sum, 0) + 1);
    }
    return count;
}
{% endhighlight %}

## Sliding Window

### Index Map

[Longest Substring Without Repeating Characters][longest-substring-without-repeating-characters]

[Max Consecutive Ones III][max-consecutive-ones-iii]

{% highlight java %}
public int longestOnes(int[] A, int K) {
    int i = 0, j = 0;
    int zero = 0, max = 0;
    while (j < A.length) {
        if (A[j] == 0) {
            zero++;
        }
        while (zero > K) {
            if (A[i++] == 0) {
                zero--;
            }
        }
        max = Math.max(max, j - i + 1);
        j++;
    }
    return max;
}
{% endhighlight %}

From @lee215:

{% highlight java %}
public int longestOnes(int[] A, int K) {
    // finds the longest subarray with at most K zeros
    int i = 0, j = 0;
    while (j < A.length) {
        if (A[j] == 0) {
            K--;
        }

        // if K < 0, both i, j move forward together
        if (K < 0 && A[i++] == 0) {
            K++;
        }
        j++;
    }

    // i, j is a sliding window.
    // its span memorizes the max range so far
    return j - i;
}
{% endhighlight %}

[Longest Repeating Character Replacement][longest-repeating-character-replacement]

{% highlight java %}
public int characterReplacement(String s, int k) {
    int[] count = new int[26];
    int i = 0, j = 0;
    int max = 0, length = 0;
    while (j < s.length()) {
        // the sliding window never shrinks, even if it covers an invalid substring
        // grows the window when the count of the new char exceeds the historical max count
        max = Math.max(max, ++count[s.charAt(j) - 'A']);
        // window size is j - i + 1
        // right shifts the whole window by one
        if (j - i + 1 - max > k) {
            count[s.charAt(i) - 'A']--;
            i++;
        }
        length = Math.max(length, j - i + 1);
        j++;
    }
    return length;
}
{% endhighlight %}

[Count Number of Nice Subarrays][count-number-of-nice-subarrays]

If we apply `nums[i] -> nums[i] % 2`, the problem becomes [Subarray Sum Equals K][subarray-sum-equals-k]

Another solution is by "three" pointers:

{% highlight java %}
public int numberOfSubarrays(int[] nums, int k) {
    int i = 0, j = 0, count = 0, result = 0;
    while (j < nums.length) {
        if (nums[j] % 2 == 1) {
            k--;
            count = 0;
        }

        while (k == 0) {
            k += nums[i++] % 2;
            count++;
        }

        // i moves forward by `count` steps in the last move
        result += count;
        j++;
    }

    return result;
}
{% endhighlight %}

### Minimum Length

[Minimum Size Subarray Sum][minimum-size-subarray-sum]

{% highlight java %}
public int minSubArrayLen(int s, int[] nums) {
    int i = 0, j = 0, sum = 0, min = nums.length + 1;
    while (j < nums.length) {
        s -= nums[j++];

        while (s <= 0) {
            min = Math.min(min, j - i);
            s += nums[i++];
        }
    }

    return min == nums.length + 1 ? 0 : min;
}
{% endhighlight %}

### At Most K Different Elements

[Subarrays with K Different Integers][subarrays-with-k-different-integers]

{% highlight java %}
public int subarraysWithKDistinct(int[] A, int K) {
    return atMost(A, K) - atMost(A, K - 1);
}

private int atMost(int[] A, int K) {
    int[] count = new int[A.length + 1];
    int i = 0, j = 0, result = 0;
    while (j < A.length) {
        if (count[A[j]] == 0) {
            K--;
        }
        count[A[j]]++;

        while (K < 0) {
            if (--count[A[i++]] == 0) {
                K++;
            }
        }

        // (j - i + 1) is the length of each valid contiguous subarray with at most K different integers
        // Fomula: given an array of length n, it will produce (n * (n + 1)) / 2 total contiguous subarrays
        result += j - i + 1;
        j++;
    }

    return result;
}
{% endhighlight %}

[Count Number of Nice Subarrays][count-number-of-nice-subarrays]

{% highlight java %}
public int numberOfSubarrays(int[] nums, int k) {
    return atMost(nums, k) - atMost(nums, k - 1);
}

private int atMost(int[] nums, int k) {
    int i = 0, j = 0, result = 0;
    while (j < nums.length) {
        k -= nums[j] % 2;

        while (k < 0) {
            k += nums[i++] % 2;
        }

        result += j - i + 1;
        j++;
    }

    return result;
}
{% endhighlight %}

## Dynamic Programming

[Find Two Non-overlapping Sub-arrays Each With Target Sum][find-two-non-overlapping-sub-arrays-each-with-target-sum]

{% highlight java %}
private final int MAX = 100_001;

public int minSumOfLengths(int[] arr, int target) {
    // minimum length sum of subarrays with target sum
    int dp[] = new int[arr.length];

    // sliding window
    int sum = 0, start = 0, result = MAX, min = MAX;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
        while (sum > target){
            sum -= arr[start];
            start++;
        }

        if (sum == target) {
            if (start > 0 && dp[start - 1] != 0) {
                result = Math.min(result, dp[start - 1] + i - start + 1);
            }
            min = Math.min(min, i - start + 1);
        }
        dp[i] = min;
    }

    return result == MAX ? -1 : result;
}
{% endhighlight %}

Generalization: `N` non-overlapping subarrays

{% highlight java %}
{% endhighlight %}

[count-number-of-nice-subarrays]: https://leetcode.com/problems/count-number-of-nice-subarrays/
[find-two-non-overlapping-sub-arrays-each-with-target-sum]: https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/
[longest-repeating-character-replacement]: https://leetcode.com/problems/longest-repeating-character-replacement/
[longest-substring-without-repeating-characters]: https://leetcode.com/problems/longest-substring-without-repeating-characters/
[max-consecutive-ones-iii]: https://leetcode.com/problems/max-consecutive-ones-iii/
[minimum-size-subarray-sum]: https://leetcode.com/problems/minimum-size-subarray-sum/
[subarray-sum-equals-k]: https://leetcode.com/problems/subarray-sum-equals-k/
[subarrays-with-k-different-integers]: https://leetcode.com/problems/subarrays-with-k-different-integers/
