---
layout: post
title:  "Graph"
tags: graph
---

# Directed Graph

[Directed graph](https://en.wikipedia.org/wiki/Directed_graph)

## Degree
[Find the Town Judge][find-the-town-judge]

{% highlight java %}
public int findJudge(int N, int[][] trust) {
    int[] degree = new int[N];
    for (int[] t : trust) {
        degree[t[0] - 1]--;
        degree[t[1] - 1]++;
    }

    for (int i = 0; i < N; i++) {
        if (degree[i] == N - 1) {
            return i + 1;
        }
    }
    return -1;
}
{% endhighlight %}

[Find the Celebrity][find-the-celebrity]

{% highlight java %}
public int findCelebrity(int n) {
    // finds the only candidate if it exists
    int candidate = 0;
    for (int i = 1; i < n; i++) {
        if (knows(candidate, i)) {
            candidate = i;
        }
    }

    for (int i = 0; i < n; i++) {
        // knows(candidate, i) is already checked in the first pass
        if ((i < candidate && (knows(candidate, i) || !knows(i, candidate))) ||
            (i > candidate && !knows(i, candidate))) {
            return -1;
        }
    }
    return candidate;
}
{% endhighlight %}

[Evaluate Division][evaluate-division]

{% highlight java %}
private Map<String, Map<String, Double>> graph = new HashMap<>();

public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    buildGraph(equations, values);

    double[] result = new double[queries.size()];
    for (int i = 0; i < queries.size(); i++) {
        List<String> q = queries.get(i);
        result[i] = getPathWeight(q.get(0), q.get(1), new HashSet<>());
    }
    return result;
}

private double getPathWeight(String start, String end, Set<String> visited) {
    if (!graph.containsKey(start)) {
        return -1.0;
    }

    if (graph.get(start).containsKey(end)) {
        return graph.get(start).get(end);
    }

    // dfs
    visited.add(start);
    for (Map.Entry<String, Double> neighbour : graph.get(start).entrySet()) {
        if (!visited.contains(neighbour.getKey())) {
            double productWeight = getPathWeight(neighbour.getKey(), end, visited);
            if (productWeight != -1.0) {
                return neighbour.getValue() * productWeight;
            }
        }
    }

    return -1.0;
}

// A / B = k
// A : (B : k)
// B : (A : 1 / k)
private void buildGraph(List<List<String>> equations, double[] values) {
    for (int i = 0; i < equations.size(); i++) {
        List<String> e = equations.get(i);

        graph.putIfAbsent(e.get(0), new HashMap<>());
        graph.get(e.get(0)).put(e.get(1), values[i]);

        graph.putIfAbsent(e.get(1), new HashMap<>());
        graph.get(e.get(1)).put(e.get(0), 1 / values[i]);
    }
}
{% endhighlight %}

# Undirected Graph

[Graph Valid Tree][graph-valid-tree]

{% highlight java %}
private List<Set<Integer>> graph;
private Set<Integer> visited;

public boolean validTree(int n, int[][] edges) {
    if (n != edges.length + 1) {
        return false;
    }

    this.graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        graph.add(new HashSet<>());
    }
    for (int[] e : edges) {
        graph.get(e[0]).add(e[1]);
        graph.get(e[1]).add(e[0]);
    }

    // checks if the graph is fully connected
    this.visited = new HashSet<>();
    dfs(0);

    return visited.size() == n;
}

private void dfs(int node) {
    if (visited.contains(node)) {
        return;
    }

    visited.add(node);
    for (int neighbor : graph.get(node)) {
        dfs(neighbor);
    }
}
{% endhighlight %}

Another solution is by disjoint set.

# Bipartite

[Is Graph Bipartite][is-graph-bipartite]

{% highlight java %}
public boolean isBipartite(int[][] graph) {
    int[] colors = new int[graph.length];
    // checks all unvisited vertex since the graph might be disconnected
    for (int i = 0; i < graph.length; i++) {
        if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {
            return false;
        }
    }
    return true;
}

private boolean dfs(int[][] graph, int[] colors, int index, int color) {
    if (colors[index] != 0) {
        return colors[index] == color;
    }

    colors[index] = color;
    for (int neighbor : graph[index]) {
        if (!dfs(graph, colors, neighbor, -color)) {
            return false;
        }
    }
    return true;
}
{% endhighlight %}

[evaluate-division]: https://leetcode.com/problems/evaluate-division/
[find-the-celebrity]: https://leetcode.com/problems/find-the-celebrity/
[find-the-town-judge]: https://leetcode.com/problems/find-the-town-judge/
[graph-valid-tree]: https://leetcode.com/problems/graph-valid-tree/
[is-graph-bipartite]: https://leetcode.com/problems/is-graph-bipartite/
