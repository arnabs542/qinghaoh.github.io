---
layout: post
title:  "Dijkstra"
tags: graph
---
[Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)

Dijkstra's Shortest Path First algorithm (SPF algorithm) is an algorithm for finding the shortest paths between nodes in a graph

[Path with Maximum Probability][path-with-maximum-probability]

{% highlight java %}
public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
    // builds graph
    Map<Integer, List<int[]>> graph = new HashMap<>();  // node : (neighbor : prob index)
    for (int i = 0; i < edges.length; i++) {
        int[] edge = edges[i];
        graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(new int[]{edge[1], i});
        graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(new int[]{edge[0], i});
    }

    // Dijkstra
    double[] p = new double[n];
    p[start] = 1;

    // max heap
    Queue<Integer> pq = new PriorityQueue<>(Comparator.comparingDouble(i -> -p[i]));
    int node = start;
    pq.offer(node);

    while (!pq.isEmpty() && node != end) {
        node = pq.poll();

        if (!graph.containsKey(node)) {
            continue;
        }

        for (int[] pair : graph.get(node)) {
            int neighbor = pair[0], index = pair[1];
            if (p[node] * succProb[index] > p[neighbor]) {
                p[neighbor] = p[node] * succProb[index];
                pq.offer(neighbor);
            }
        }
    }

    return p[end];
}
{% endhighlight %}

DFS will underflow or LTE.

## Within K Steps

[Cheapest Flights Within K Stops][cheapest-flights-within-k-stops]

{% highlight java %}
public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    // buils graph
    Map<Integer, List<int[]>> graph = new HashMap<>();
    for (int[] f : flights) {
        graph.computeIfAbsent(f[0], k -> new ArrayList<>()).add(new int[]{f[1], f[2]});
    }

    // Dijkstra
    int[] node = {src, 0, K};  // city, price, stops
    Queue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
    pq.add(node);

    while (!pq.isEmpty()) {
        node = pq.poll();

        if (node[0] == dst) {
            return node[1];
        }

        if (node[2] >= 0) {
            if (!graph.containsKey(node[0])) {
                continue;
            }

            for (int[] pair : graph.get(node[0])) {
                // some nodes may have the same city due to different paths
                pq.offer(new int[]{pair[0], node[1] + pair[1], node[2] - 1});
            }
        }
    }

    return -1;
}
{% endhighlight %}

[Path with Minimum Effort][path-with-minimum-effort]

{% highlight java %}
{% raw %}
private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
{% endraw %}
private static final int MAX = (int)1e6;

public int minimumEffortPath(int[][] heights) {
    int m = heights.length, n = heights[0].length;
    int[][] effort = new int[m][n];
    for (int[] e : effort) {
        Arrays.fill(e, MAX);
    }

    // i, j, effort
    Queue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));
    pq.offer(new int[]{0, 0, 0});

    while (!pq.isEmpty()) {
        int[] node = pq.poll();
        int i = node[0], j = node[1], e = node[2];
        if (e > effort[i][j]) {
            continue;
        }
        if (i == m - 1 && j == n - 1) {
            return e;
        }
        for (int[] d : DIRECTIONS) {
            int r = i + d[0], c = j + d[1];
            if (r == m || r < 0 || c == n || c < 0) {
                continue;
            }
            int v = Math.max(Math.abs(heights[r][c] - heights[i][j]), e);
            if (v < effort[r][c]) {
                effort[r][c] = v;
                pq.offer(new int[]{r, c, v});
            }
        }
    }
    return -1;
}
{% endhighlight %}

[cheapest-flights-within-k-stops]: https://leetcode.com/problems/cheapest-flights-within-k-stops/
[path-with-maximum-probability]: https://leetcode.com/problems/path-with-maximum-probability/
[path-with-minimum-effort]: https://leetcode.com/problems/path-with-minimum-effort/
