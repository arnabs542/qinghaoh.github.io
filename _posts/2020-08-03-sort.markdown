---
layout: post
title:  "Sort"
tags: sort
---
[Sort an Array][sort-an-array]

## Quick sort
### Lumuto Partition Scheme
{% highlight java %}
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}
    
private void quickSort(int[] nums, int low, int high) {
    if (low < high) {
        int p = partition(nums, low, high);
        quickSort(nums, low, p - 1);
        quickSort(nums, p + 1, high);
    }
}
    
private int partition(int[] nums, int low, int high) {
    int pivot = nums[high];
    int i = low;
    for (int j = low; j < high; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, high);
    return i;
}
    
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
{% endhighlight %}

## Merge Sort
{% highlight java %}
// Top-down
public int[] sortArray(int[] nums) {
    mergeSort(nums, 0, nums.length - 1);
    return nums;
}

private void mergeSort(int[] nums, int low, int high) {
    if (low < high) {
        int mid = (low + high) >>> 1;
        mergeSort(nums, low, mid);
        mergeSort(nums, mid + 1, high);
        merge(nums, low, high);
    }
}

private void merge(int[] nums, int low, int high) {
    int[] tmp = new int[high - low + 1];
    int mid = (low + high) >>> 1;
    int i = low, j = mid + 1;

    for (int k = 0; k < tmp.length; k++) {
        if (i <= mid && (j > high || nums[i] <= nums[j])) {
            tmp[k] = nums[i++];
        } else {
            tmp[k] = nums[j++];
        }
    }

    System.arraycopy(tmp, 0, nums, low, tmp.length);
}
{% endhighlight %}

[Count of Smaller Numbers After Self][count-of-smaller-numbers-after-self]

{% highlight java %}
private int[] counts;

public List<Integer> countSmaller(int[] nums) {
    counts = new int[nums.length];

    // index[i] == j means the element at index i is nums[j]
    int[] index = new int[nums.length];
    for (int i = 0; i < index.length; i++) {
        index[i] = i;
    }

    mergeSort(nums, index, 0, nums.length - 1);
    return Arrays.stream(counts).boxed().collect(Collectors.toList());
}

private void mergeSort(int[] nums, int[] index, int low, int high) {
    if (low < high) {
        int mid = (low + high) >>> 1;
        mergeSort(nums, index, low, mid);
        mergeSort(nums, index, mid + 1, high);
        merge(nums, index, low, high);
    }
}

private void merge(int[] nums, int[] index, int low, int high) {
    int mid = (low + high) >>> 1;
    int i = low, j = mid + 1;
    int[] tmp = new int[high - low + 1];  // sort index by the order of its element

    int count = 0;  // count of left elements that are great than the current right element
    for (int k = 0; k < tmp.length; k++) {
        if (i <= mid && (j > high || nums[index[i]] <= nums[index[j]])) {
            counts[index[i]] += count;
            tmp[k] = index[i++];
        } else {
            // nums[index[i]] > nums[index[j]]
            if (i <= mid) {
                count++;
            }
            tmp[k] = index[j++];
        }
    }

    System.arraycopy(tmp, 0, index, low, tmp.length);
}
{% endhighlight %}

```
nums: [5,2,6,1]

low: 0, high: 1
index: [0,1,2,3] -> [1,0,2,3]
counts: [0,0,0,0] -> [1,0,0,0]

low: 2, high: 3
index: [1,0,2,3] -> [1,0,3,2]
counts: [1,0,0,0] -> [1,0,1,0]

low: 0, high: 3
index: [1,0,3,2] -> [3,1,0,2]
counts: [1,0,1,0] -> [2,1,1,0]
```

## Bucket Sort
[H-Index][h-index]

{% highlight java %}
public int hIndex(int[] citations) {        
    int[] count = new int[citations.length + 1];
    for (int c : citations) {
        if (c >= citations.length) {
            count[citations.length]++;
        } else {
            count[c]++;
        }
    }

    int sum = 0;
    for (int i = count.length - 1; i > 0; i--) {
        sum += count[i];
        if (sum >= i) {
            return i;
        }
    }
    return 0;
}
{% endhighlight %}

## Counting Sort
[Counting sort](https://en.wikipedia.org/wiki/Counting_sort)
[Find Lucky Integer in an Array][find-lucky-integer-in-an-array]

{% highlight java %}
// 0 <= arr[i] <= max
public int countingSort(int[] arr) {
    // histogram
    int[] count = new int[max + 1];
    for (int a : arr) {
        count[a]++;
    }

    // computes prefix sum
    for (int i = 1; i < count.length; i++) {
        count[i] += count[i - 1];
    }

    int[] result = new int[arr.length];
    for (int a : arr) {
        result[count[a]] = a;
        count[a]++;
    }

    return result;
}
{% endhighlight %}

[count-of-smaller-numbers-after-self]: https://leetcode.com/problems/count-of-smaller-numbers-after-self/
[find-lucky-integer-in-an-array]: https://leetcode.com/problems/find-lucky-integer-in-an-array/
[h-index]: https://leetcode.com/problems/h-index/
[sort-an-array]: https://leetcode.com/problems/sort-an-array/
