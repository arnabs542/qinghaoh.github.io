---
layout: post
title:  "Sort"
tags: sort
---
[Sort an Array][sort-an-array]

## Quick sort
### Lumuto Partition Scheme
{% highlight java %}
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}
    
private void quickSort(int[] nums, int low, int high) {
    if (low < high) {
        int p = partition(nums, low, high);
        quickSort(nums, low, p - 1);
        quickSort(nums, p + 1, high);
    }
}
    
private int partition(int[] nums, int low, int high) {
    int pivot = nums[high];
    int i = low;
    for (int j = low; j < high; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, high);
    return i;
}
    
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
{% endhighlight %}

## Merge Sort
{% highlight java %}
// Top-down
public int[] sortArray(int[] nums) {
    mergeSort(nums, 0, nums.length - 1);
    return nums;
}

private void mergeSort(int[] nums, int low, int high) {
    if (low < high) {
        int mid = (low + high) >>> 1;
        mergeSort(nums, low, mid);
        mergeSort(nums, mid + 1, high);
        merge(nums, low, high);
    }
}

private void merge(int[] nums, int low, int high) {
    int[] tmp = new int[high - low + 1];
    int mid = (low + high) >>> 1;
    int i = low, j = mid + 1;

    for (int k = 0; k < tmp.length; k++) {
        if (i <= mid && (j > high || nums[i] <= nums[j])) {
            tmp[k] = nums[i++];
        } else {
            tmp[k] = nums[j++];
        }
    }

    System.arraycopy(tmp, 0, nums, low, tmp.length);
}
{% endhighlight %}

[Count of Smaller Numbers After Self][count-of-smaller-numbers-after-self]

{% highlight java %}
private int[] counts;

public List<Integer> countSmaller(int[] nums) {
    counts = new int[nums.length];

    // index[i] == j means the element at index i is nums[j]
    int[] index = new int[nums.length];
    for (int i = 0; i < index.length; i++) {
        index[i] = i;
    }

    mergeSort(nums, index, 0, nums.length - 1);
    return Arrays.stream(counts).boxed().collect(Collectors.toList());
}

private void mergeSort(int[] nums, int[] index, int low, int high) {
    if (low < high) {
        int mid = (low + high) >>> 1;
        mergeSort(nums, index, low, mid);
        mergeSort(nums, index, mid + 1, high);
        merge(nums, index, low, high);
    }
}

private void merge(int[] nums, int[] index, int low, int high) {
    int mid = (low + high) >>> 1;
    int i = low, j = mid + 1;
    int[] tmp = new int[high - low + 1];  // sort index by the order of its element

    int count = 0;  // count of left elements that are great than the current right element
    for (int k = 0; k < tmp.length; k++) {
        if (i <= mid && (j > high || nums[index[i]] <= nums[index[j]])) {
            counts[index[i]] += count;
            tmp[k] = index[i++];
        } else {
            // nums[index[i]] > nums[index[j]]
            if (i <= mid) {
                count++;
            }
            tmp[k] = index[j++];
        }
    }

    System.arraycopy(tmp, 0, index, low, tmp.length);
}
{% endhighlight %}

```
nums: [5,2,6,1]

low: 0, high: 1
index: [0,1,2,3] -> [1,0,2,3]
counts: [0,0,0,0] -> [1,0,0,0]

low: 2, high: 3
index: [1,0,2,3] -> [1,0,3,2]
counts: [1,0,0,0] -> [1,0,1,0]

low: 0, high: 3
index: [1,0,3,2] -> [3,1,0,2]
counts: [1,0,1,0] -> [2,1,1,0]
```

## Bucket Sort
[H-Index][h-index]

{% highlight java %}
public int hIndex(int[] citations) {        
    int[] count = new int[citations.length + 1];
    for (int c : citations) {
        if (c >= citations.length) {
            count[citations.length]++;
        } else {
            count[c]++;
        }
    }

    int sum = 0;
    for (int i = count.length - 1; i > 0; i--) {
        sum += count[i];
        if (sum >= i) {
            return i;
        }
    }
    return 0;
}
{% endhighlight %}

[Car Pooling][car-pooling]

{% highlight java %}
public boolean carPooling(int[][] trips, int capacity) {
    Map<Integer, Integer> map = new TreeMap<>();
    for (int[] t : trips) {
        map.put(t[1], map.getOrDefault(t[1], 0) + t[0]);
        map.put(t[2], map.getOrDefault(t[2], 0) - t[0]);
    }

    for (int v : map.values()) {
        capacity -= v;
        if (capacity < 0) {
            return false;
        }
    }

    return true;
}
{% endhighlight %}

## Counting Sort
[Counting sort](https://en.wikipedia.org/wiki/Counting_sort)

[Find Lucky Integer in an Array][find-lucky-integer-in-an-array]

{% highlight java %}
// 0 <= arr[i] <= max
public int countingSort(int[] arr) {
    // histogram
    int[] count = new int[max + 1];
    for (int a : arr) {
        count[a]++;
    }

    // computes prefix sum
    for (int i = 1; i < count.length; i++) {
        count[i] += count[i - 1];
    }

    int[] result = new int[arr.length];
    for (int i = arr.length - 1; i >= 0; i--) {
        result[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }

    return result;
}
{% endhighlight %}

[Special Array With X Elements Greater Than or Equal X][special-array-with-x-elements-greater-than-or-equal-x]

{% highlight java %}
private int MAX_LENGTH = 100;

public int specialArray(int[] nums) {
    int[] count = new int[MAX_LENGTH + 2];

    // x <= nums.length
    for (int num : nums) {
        count[Math.min(num, nums.length)]++;
    }

    for (int i = nums.length; i >= 0; i--) {
        count[i] += count[i + 1];
        if (count[i] == i) {
            return i;
        }
    }
    return -1;
}
{% endhighlight %}

## Dutch National Flag Problem

[Dutch national flag problem](https://en.wikipedia.org/wiki/Dutch_national_flag_problem)

[Sort Colors][sort-colors]

{% highlight java %}
public void sortColors(int[] A) {
    int red = 0, blue = A.length - 1;
    int i = red;
    while (i <= blue) {
        if (A[i] == 0) {
            swap(A, i++, red++);
        } else if (A[i] == 2) {
            swap(A, i, blue--);
        } else {
            i++;
        }
    }
}

private void swap(int[] A, int i, int j) {
    int tmp = A[i];
    A[i] = A[j];
    A[j] = tmp;
}
{% endhighlight %}

[Wiggle Sort II][wiggle-sort-ii]

{% highlight java %}
public void wiggleSort(int[] nums) {
    int[] copy = Arrays.copyOf(nums, nums.length);
    Arrays.sort(copy);

    int median = (nums.length + 1) / 2 - 1;
    int high = nums.length - 1;
    for (int i = 0; i < nums.length; i++) {
        nums[i] = copy[i % 2 == 0 ? median-- : high--];
    }
}
{% endhighlight %}

Index mapping:

{% highlight java %}
public void wiggleSort(int[] nums) {
    int n = nums.length;
    int median = findKthLargest(nums, (n + 1) / 2);

    // dutch national flag sort on the virtual array
    int left = 0, right = n - 1;
    int i = 0;
    while (i <= right) {
        // puts smaller half of the numbers on the even indexes,
        // and the larger half on the odd indexes,
        // both from right to left
        if (nums[mapIndex(i, n)] > median) {
            swap(nums, mapIndex(i++, n), mapIndex(left++, n));
        } else if (nums[mapIndex(i, n)] < median) {
            swap(nums, mapIndex(i, n), mapIndex(right--, n));
        } else {
            i++;
        }
    }
}

/**
 * Maps the virtual index to array index.
 * e.g. if n == 6,
 * 0 -> 1
 * 1 -> 3
 * 2 -> 5
 * 3 -> 0
 * 4 -> 2
 * 5 -> 4
 * @param index virtual index
 * @param n array size
 */
private int mapIndex(int index, int n) {
    // (n | 1) is the least odd that's no less than n
    return (1 + 2 * index) % (n | 1);
}

// O(n) on average
private int findKthLargest(int[] nums, int k) {
    return quickSelect(nums, 0, nums.length - 1, k);
}

private int quickSelect(int[] nums, int low, int high, int k) {
    int p = partition(nums, low, high);

    // count of nums greater than or equal to nums[p]
    int count = high - p + 1;
    if (count == k) {
        return nums[p];
    }

    if (count > k) {
        return quickSelect(nums, p + 1, high, k);
    }

    return quickSelect(nums, low, p - 1, k - count);
}

private int partition(int[] nums, int low, int high) {
    int pivot = nums[high];
    int i = low;
    for (int j = low; j < high; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, high);
    return i;
}

private void swap(int[] A, int i, int j) {
    int tmp = A[i];
    A[i] = A[j];
    A[j] = tmp;
}
{% endhighlight %}

[car-pooling]: https://leetcode.com/problems/car-pooling/
[count-of-smaller-numbers-after-self]: https://leetcode.com/problems/count-of-smaller-numbers-after-self/
[find-lucky-integer-in-an-array]: https://leetcode.com/problems/find-lucky-integer-in-an-array/
[h-index]: https://leetcode.com/problems/h-index/
[sort-an-array]: https://leetcode.com/problems/sort-an-array/
[sort-colors]: https://leetcode.com/problems/sort-colors/
[special-array-with-x-elements-greater-than-or-equal-x]: https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/
[wiggle-sort-ii]: https://leetcode.com/problems/wiggle-sort-ii/
