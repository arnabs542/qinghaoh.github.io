---
layout: post
title:  "Stack"
tags: stack
---
## Monotonic Stack

[Remove K Digits][remove-k-digits]

Use StringBuilder as a stack.

{% highlight java %}
public String removeKdigits(String num, int k) {
    StringBuilder sb = new StringBuilder();
    int count = 0;
    for (char c : num.toCharArray()) {
        while (sb.length() > 0 && sb.charAt(sb.length()-1) > c && count < k){
            sb.deleteCharAt(sb.length() - 1);
            count++;
        }
        if (sb.length() == 0 && c == '0') {
            continue;
        }
        sb.append(c);
    }

    while (count < k && sb.length() > 0) {
        sb.deleteCharAt(sb.length() - 1);
        count++;
    }
    return sb.length() == 0 ? "0" : sb.toString();
}
{% endhighlight %}

### Templates

#### Previous Less Element

{% highlight java %}
int[] prev = new int[nums.length];
Deque<Integer> st = new ArrayDeque<>();
for (int i = 0; i < nums.length; i++) {
    // monotonically increasing stack
    // non-strict
    while (!st.isEmpty() && num[st.peek()] > nums[i]) {
        st.pop();
    }
    prev[i] = st.isEmpty() ? -1 : st.peek();
    st.push(i);
}
{% endhighlight %}

#### Next Less Element

{% highlight java %}
int[] next = new int[nums.length];
Arrays.fill(next, -1);
Deque<Integer> st = new ArrayDeque<>();
for (int i = 0; i < nums.length; i++) {
    // monotonically increasing stack
    // strict
    while (!st.isEmpty() && num[st.peek()] > nums[i]) {
        next[st.pop()] = i;
    }
    st.push(i);
}
{% endhighlight %}

[Final Prices With a Special Discount in a Shop][final-prices-with-a-special-discount-in-a-shop]

{% highlight java %}
public int[] finalPrices(int[] prices) {
    int[] result = Arrays.copyOf(prices, prices.length);

    // next less element
    Deque<Integer> st = new ArrayDeque<>();
    for (int i = 0; i < result.length; i++) {
        while (!st.isEmpty() && result[st.peek()] >= result[i]) {
            result[st.pop()] -= result[i];
        }
        st.push(i);
    }
    return result;
}
{% endhighlight %}

[Next Greater Element II][next-greater-element-ii]

[Next Greater Node in Linked List][next-greater-node-in-linked-list]

[Online Stock Span][online-stock-span]

{% highlight java %}
private Deque<int[]> st;

public StockSpanner() {
    st = new ArrayDeque<>();
}

public int next(int price) {
    int count = 1;
    while (!st.isEmpty() && st.peek()[0] <= price) {
        count += st.pop()[1];
    }    
    st.push(new int[]{price, count});
    return count;
}
{% endhighlight %}

[Sum of Subarray Minimums][sum-of-subarray-minimums]

{% highlight java %}
private int MOD = (int)1e9 + 7;

public int sumSubarrayMins(int[] A) {
    // left[i]:  distance between A[i] and its previous less element (prev, A[i]]
    // right[i]: distance between A[i] and its next less element [A[i], next)
    int[] left = new int[A.length], right = new int[A.length];
    for (int i = 0; i < A.length; i++) {
        right[i] = A.length - i;
    }

    // element : index
    Deque<Integer> st1 = new ArrayDeque<>(), st2 = new ArrayDeque<>();
    int result = 0;

    for (int i = 0; i < A.length; i++) {
        // previous less element (non-strict)
        while (!st1.isEmpty() && A[st1.peek()] > A[i]) {
            st1.pop();
        }
        left[i] = i - (st1.isEmpty()? -1 : st1.peek());
        st1.push(i);

        // next less element (strict)
        while (!st2.isEmpty() && A[st2.peek()] > A[i]) {
            int index = st2.pop();
            right[index] = i - index;
        }
        st2.push(i);
    }

    for (int i = 0; i < A.length; i++) {
        result = (result + A[i] * left[i] * right[i]) % MOD;
    }
    return result;
}
{% endhighlight %}

{% highlight java %}
private int MOD = (int)1e9 + 7;

public int sumSubarrayMins(int[] A) {
    Deque<Integer> st = new ArrayDeque<>();
    int result = 0;
    for (int i = 0; i <= A.length; i++) {
        while (!st.isEmpty() && A[st.peek()] > (i == A.length ? 0 : A[i])) {
            int j = st.pop();
            int k = st.isEmpty() ? -1 : st.peek();
            result = (result + A[j] * (i - j) * (j - k)) % MOD;
        }
        st.push(i);
    }
    return result;
}
{% endhighlight %}

Similarly, with Monotonically Increasing Stack, we can get Previous Greater Element or Next Greater Element.

[Minimum Cost Tree From Leaf Values][minimum-cost-tree-from-leaf-values]

{% highlight java %}
public int mctFromLeafValues(int[] arr) {
    Deque<Integer> st = new ArrayDeque<>();
    st.push(Integer.MAX_VALUE);

    int sum = 0;
    for (int a : arr) {
        // previous and next greater element
        while (st.peek() <= a) {
            int top = st.pop();
            sum += top * Math.min(st.peek(), a);
        }
        st.push(a);
    }

    while (st.size() > 2) {
        sum += st.pop() * st.peek();
    }

    return sum;
}
{% endhighlight %}

[Largest Rectangle in Histogram][largest-rectangle-in-histogram]

{% highlight java %}
public int largestRectangleArea(int[] heights) {
    // index of non-descending heights
    Deque<Integer> st = new ArrayDeque<>();
    int area = 0;
    for (int i = 0; i <= heights.length; i++) {            
        int height = (i == heights.length ? 0 : heights[i]);
        while (!st.isEmpty() && height < heights[st.peek()]) {
            int h = heights[st.pop()];
            int w = st.isEmpty() ? i : (i - 1) - st.peek();
            area = Math.max(area, h * w);
        }
        st.push(i);
    }
    return area;
}
{% endhighlight %}

```
[2,1,5,6,2,3]
i = 0	[0]				area = 0
i = 1	[]		h * w = 2	area = 2
i = 1	[1]				area = 2
i = 2	[2,1]				area = 2
i = 3	[3,2,1]				area = 2
i = 4	[2,1]		h * w = 6	area = 6
i = 4	[1]		h * w = 10	area = 10
i = 4	[4,1]				area = 10
i = 5	[5,4,1]				area = 10
i = 6	[4,1]		h * w = 3	area = 10
i = 6	[1]		h * w = 8	area = 10
i = 6	[]		h * w = 6	area = 10
i = 6	[6]				area = 10
```

[Maximal Rectangle][maximal-rectangle]

{% highlight java %}
public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }

    int m = matrix.length, n = matrix[0].length;
    int area = 0;
    int[] height = new int[n + 1];

    for (int row = 0; row < m; row++) {
        Deque<Integer> st = new ArrayDeque<>();
        for (int i = 0; i <= n; i++) {
            if (i < n && matrix[row][i] == '1') {
                height[i] += 1;
            } else {
                height[i] = 0;
            }

            while (!st.isEmpty() && height[i] < height[st.peek()]) {
                int h = height[st.pop()];
                int w = st.isEmpty() ? i : (i - 1) - st.peek();
                area = Math.max(area, h * w);
            }
            st.push(i);
        }
    }

    return area;
}
{% endhighlight %}

[Remove Duplicate Letters][remove-duplicate-letters]

{% highlight java %}
public String removeDuplicateLetters(String s) {
    // last index
    int[] last = new int[26];
    for (int i = 0; i < s.length(); ++i) {
        last[s.charAt(i) - 'a'] = i;
    }

    Deque<Integer> st = new ArrayDeque<>();
    // if visited is true, it's already in the stack
    boolean[] visited = new boolean[26];
    for (int i = 0; i < s.length(); i++) {
        int c = s.charAt(i) - 'a';
        if (!visited[c]) {
            // if c is greater than stack top, and the top appears later,
            // pops the top
            while (!st.isEmpty() && st.peek() > c && i < last[st.peek()]) {
                visited[st.pop()] = false;
            }
            st.push(c);
            visited[c] = true;
        }
    }

    StringBuilder sb = new StringBuilder();
    for (int i : st) {
        sb.append((char)('a' + i));
    }
    return sb.reverse().toString();
}
{% endhighlight %}

[132 Pattern][132-pattern]

{% highlight java %}
private int MIN = (int)(-1e9);

public boolean find132pattern(int[] nums) {
    Deque<Integer> st = new ArrayDeque<>();
    int mid = MIN;
    for (int i = nums.length - 1; i >= 0; i--) {
        if (nums[i] < mid) {
            return true;
        }

        // monotonically decreasing stack
        // finds the largest mid for the current high (nums[i])
        while (!st.isEmpty() && nums[i] > st.peek()) {
            mid = st.pop(); 
        }
        st.push(nums[i]);
    }
    return false;
}
{% endhighlight %}

[Reverse Substrings Between Each Pair of Parentheses][reverse-substrings-between-each-pair-of-parentheses]

{% highlight java %}
public String reverseParentheses(String s) {
    Deque<Integer> st = new ArrayDeque<>();
    int[] pairs = new int[s.length()];
    for (int i = 0; i < s.length(); ++i) {
        if (s.charAt(i) == '(')
            st.push(i);
        if (s.charAt(i) == ')') {
            int j = st.pop();
            pairs[i] = j;
            pairs[j] = i;
        }
    }

    StringBuilder sb = new StringBuilder();
    for (int i = 0, d = 1; i < s.length(); i += d) {
        if (s.charAt(i) == '(' || s.charAt(i) == ')') {
            i = pairs[i];
            d = -d;  // changes direction
        } else {
            sb.append(s.charAt(i));
        }
    }

    return sb.toString();
}
{% endhighlight %}

## Reduced to Counter
[Remove Outermost Parentheses][remove-outermost-parentheses]

{% highlight java %}
public string removeouterparentheses(string s) {
    stringbuilder sb = new stringbuilder();
    int open = 0;
    for (char c : s.tochararray()) {
        if ((c == '(' && open++ > 0) || (c == ')' && --open > 0)) {
            sb.append(c);
        }
    }
    return sb.tostring();
}
{% endhighlight %}

[Minimum Add to Make Parentheses Valid][minimum-add-to-make-parentheses-valid]

{% highlight java %}
public int minAddToMakeValid(String S) {
    int notOpened = 0;  // '(' needed to make the String balanced
    int notClosed = 0;  // ')' needed to make the String balanced
    for (char c : S.toCharArray()) {
        if (c == '(') {
            notClosed++;
        } else if (notClosed == 0) {
            notOpened++;
        } else {
            notClosed--;
        }
    }

    return notOpened + notClosed;
}
{% endhighlight %}

[Minimum Insertions to Balance a Parentheses String][minimum-insertions-to-balance-a-parentheses-string]

{% highlight java %}
public int minInsertions(String s) {
    int count = 0;
    int notClosed = 0;  // ')' needed to make the String balanced
    for (char c : s.toCharArray()) {
        if (c == '(') {
            if (notClosed % 2 > 0) {
                notClosed--;
                count++;
            }
            notClosed += 2;
        } else {
            notClosed--;
            if (notClosed < 0) {
                notClosed += 2;
                count++;
            }
        }
    }

    return count + notClosed;
}
{% endhighlight %}

[Maximum Nesting Depth of Two Valid Parentheses Strings][maximum-nesting-depth-of-two-valid-parentheses-strings]

{% highlight java %}
public int[] maxDepthAfterSplit(String seq) {
    int[] result = new int[seq.length()];
    int opened = 0;
    for (int i = 0; i < seq.length(); i++) {
        if (seq.charAt(i) == '(') {
            opened++;
        }

        result[i] = opened % 2;  // split by parity

        if (seq.charAt(i) == ')') {
            opened--;
        }
    }

    return result;
}
{% endhighlight %}

[Score of Parentheses][score-of-parentheses]

{% highlight java %}
public int scoreOfParentheses(String S) {
    Deque<Integer> st = new ArrayDeque<>();
    int curr = 0;
    for (char c : S.toCharArray()) {
        if (c == '(') {
            st.push(curr);
            curr = 0;
        } else {
            curr = st.pop() + Math.max(curr * 2, 1);
        }
    }
    return curr;
}
{% endhighlight %}

{% highlight java %}
public int scoreOfParentheses(String S) {
    int score = 0, opened = 0;
    for (int i = 0; i < S.length(); i++) {
        if (S.charAt(i) == '(') {
            opened++;
        } else {
            opened--;
            if (S.charAt(i - 1) == '(') {
                // number of exterior sets of parentheses that contains this core
                score += 1 << opened;
            }
        }
    }
    return score;
}
{% endhighlight %}

[132-pattern]: https://leetcode.com/problems/132-pattern/
[final-prices-with-a-special-discount-in-a-shop]: https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/
[largest-rectangle-in-histogram]: https://leetcode.com/problems/largest-rectangle-in-histogram/
[maximal-rectangle]: https://leetcode.com/problems/maximal-rectangle/
[maximum-nesting-depth-of-two-valid-parentheses-strings]: https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/
[minimum-add-to-make-parentheses-valid]: https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
[minimum-cost-tree-from-leaf-values]: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/
[minimum-insertions-to-balance-a-parentheses-string]: https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
[next-greater-element-ii]: https://leetcode.com/problems/next-greater-element-ii/
[next-greater-node-in-linked-list]: https://leetcode.com/problems/next-greater-node-in-linked-list/
[online-stock-span]: https://leetcode.com/problems/online-stock-span/
[score-of-parentheses]: https://leetcode.com/problems/score-of-parentheses/
[sum-of-subarray-minimums]: https://leetcode.com/problems/sum-of-subarray-minimums/
[remove-k-digits]: https://leetcode.com/problems/remove-k-digits/
[remove-duplicate-letters]: https://leetcode.com/problems/remove-duplicate-letters/
[remove-outermost-parentheses]: https://leetcode.com/problems/remove-outermost-parentheses/
[reverse-substrings-between-each-pair-of-parentheses]: https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
