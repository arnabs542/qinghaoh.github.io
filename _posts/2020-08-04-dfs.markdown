---
layout: post
title:  "DFS"
tags: dfs
---
# Template
[Keys and Rooms][keys-and-rooms]

## Recursion

{% highlight java %}
private Set<Integer> set = new HashSet<>();

public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    dfs(rooms, 0);
    return set.size() == rooms.size();
}

private void dfs(List<List<Integer>> rooms, int room) {
    if (set.contains(room)) {
        return;
    }

    set.add(room);
    for (int key : rooms.get(room)) {
        dfs(rooms, key);
    }
}
{% endhighlight %}

## Stack

{% highlight java %}
public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    Set<Integer> set = new HashSet<>();
    set.add(0);

    Deque<Integer> st = new ArrayDeque();
    st.push(0);

    while (!st.isEmpty()) {
        int room = st.pop();
        for (int key: rooms.get(room)) {
            if (!set.contains(key)) {
                set.add(key);
                st.push(key);
            }
        }
    }

    return set.size() == rooms.size();
}
{% endhighlight %}

[Pyramid Transition Matrix][pyramid-transition-matrix]

{% highlight java %}
private Map<String, Set<Character>> map;

public boolean pyramidTransition(String bottom, List<String> allowed) {
    map = new HashMap<>();
    for (String s : allowed) {
        map.computeIfAbsent(s.substring(0, 2), k -> new HashSet<>()).add(s.charAt(2));
    }

    return dfs(bottom, "", 1);
}

private boolean dfs(String row, String nextRow, int index) {
    if (row.length() == 1) {
        return true;
    }

    if (nextRow.length() + 1 == row.length()) {
        return dfs(nextRow, "", 1);
    }

    String key = row.substring(index - 1, index + 1);
    if (map.containsKey(key)) {
        for (Character c : map.get(key)) {
            if (dfs(row, nextRow + c, index + 1)) {
                return true;
            }
        }
    }

    return false;
}
{% endhighlight %}

# Bottom-up

[Time Needed to Inform All Employees][time-needed-to-inform-all-employees]

{% highlight java %}
public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
    int minutes = 0;
    for (int i = 0; i < n; i++) {
        minutes = Math.max(minutes, dfs(i, manager, informTime));
    }
    return minutes;
}

// bottom-up
public int dfs(int i, int[] manager, int[] informTime) {
    if (manager[i] != -1) {
        informTime[i] += dfs(manager[i], manager, informTime);
        // don't visit his manager twice
        manager[i] = -1;
    }
    return informTime[i];
}
{% endhighlight %}

[Clone Graph][clone-graph]

{% highlight java %}
private Map<Integer, Node> map = new HashMap<>();

public Node cloneGraph(Node node) {
    return dfs(node);
}

private Node dfs(Node node) {
    if (node == null) {
        return null;
    }

    if (map.containsKey(node.val)) {
        return map.get(node.val);
    }

    Node copy = new Node(node.val, new ArrayList<>());
    map.put(copy.val, copy);
    for (Node n : node.neighbors) {
        copy.neighbors.add(dfs(n));
    }
    return copy;
}
{% endhighlight %}

# Pattern Signature

[Number of Distinct Islands][number-of-distinct-islands]

{% highlight java %}
pattern.append(index);
for (int k = 0; k < DIRECTIONS.length; k++) {
    int[] d = DIRECTIONS[k];
    dfs(i + d[0], j + d[1], (char)('0' + k), pattern);
}
pattern.append('#');
{% endhighlight %}

![Patterns](/assets/number_of_distinct_islands.png)

```
#0#1##
#03###
```

# Brute Force

[Lexicographically Smallest String After Applying Operations][lexicographically-smallest-string-after-applying-operations]

{% highlight java %}
private String min;
private int a, b;
private Set<String> visited = new HashSet<>();

public String findLexSmallestString(String s, int a, int b) {
    this.min = s;
    this.a = a;
    this.b = b;

    dfs(s);
    return min;
}

private void dfs(String s) {
    if (!visited.add(s)) {
        return;
    }

    if (min.compareTo(s) > 0) {
        min = s;
    }

    dfs(add(s));
    dfs(rotate(s));
}

private String add(String s) {
    char[] c = s.toCharArray();
    for (int i = 1; i < c.length; i += 2) {
        c[i] = (char)((c[i] - '0' + a) % 10 + '0');
    }
    return new String(c);
}

privat String rotate(String s) {
    int n = s.length();
    return s.substring(n - b) + s.substring(0, n - b);
}
{% endhighlight %}

This solution includes all possibilities, and uses a set as termination condition.

[Lexicographical Numbers][lexicographical-numbers]

# Transitions

[The Earliest and Latest Rounds Where Players Compete][the-earliest-and-latest-rounds-where-players-compete]

{% highlight java %}
private int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;

public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
    dfs(firstPlayer, n - secondPlayer + 1, n, 1);
    return new int[]{min, max};
}

// @param l length of [1, first player]
// @param r length of [second player, n]
private void dfs(int l, int r, int n, int round) {
    if (l == r) {
        min = Math.min(min, round);
        max = Math.max(max, round);
        return;
    }

    // makes sure l < r
    if (l > r) {
        int tmp = l;
        l = r;
        r = tmp;
    }

    // i players on the left win
    for (int i = 1; i <= l; i++) {
        // (l - i) palyers on the right win
        // assumes second player is champion (+1)
        // players in the next round: (n + 1) / 2
        for (int j = l - i + 1; i + j <= Math.min(r, (n + 1) / 2); j++) {
            // losers = (l - i) + (r - j)
            if ((l - i) + (r - j) <= n / 2) {
                dfs(i, j, (n + 1) / 2, round + 1);
            }
        }
    }
}
{% endhighlight %}

![Transition](/assets/the_earliest_and_latest_rounds_where_players_compete.png)

# DFS + BFS

[Shortest Path in a Hidden Grid][shortest-path-in-a-hidden-grid]

{% highlight java %}
{% raw %}
private static final int[][] DIRECTIONS = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
{% endraw %}
private static final char[] CHARS = {'U', 'L', 'D', 'R'};
private static final int N = 500;

private enum Cell {
    UNVISITED(-1),
    BLOCKED(0),
    EMPTY(1),
    TARGET(2);

    private int value;

    Cell(int value) {
        this.value = value;
    }
}

public int findShortestPath(GridMaster master) {
    // 4 x grid, and places starting cell at the centor
    Cell[][] grid = new Cell[2 * N][2 * N];
    for (int i = 0; i < grid.length; i++) {
        Arrays.fill(grid[i], Cell.UNVISITED);
    }

    // (N, N) is the start
    dfs(N, N, master, grid);

    Queue<int[]> q = new LinkedList<>();
    q.offer(new int[]{N, N});

    // marks visited as BLOCKED
    grid[N][N] = Cell.BLOCKED;

    // bfs
    int distance = 0;
    while (!q.isEmpty()) {
        for (int i = q.size(); i > 0; i--) {
            int[] node = q.poll();
            for (int[] d : DIRECTIONS) {
                int r = node[0] + d[0], c = node[1] + d[1];
                if (grid[r][c] == Cell.TARGET) {
                    return distance + 1;
                }

                if (grid[r][c] != Cell.BLOCKED) {
                    q.offer(new int[]{r, c});
                    grid[r][c] = Cell.BLOCKED;
                }
            }
        }
        distance++;
    }

    return -1;
}

// explores the map
private void dfs(int i, int j, GridMaster master, Cell[][] grid) {
    if (grid[i][j] != Cell.UNVISITED) {
        return;
    }

    grid[i][j] = master.isTarget() ? Cell.TARGET : Cell.EMPTY;

    for (int k = 0; k < 4; k++) {
        int r = i + DIRECTIONS[k][0], c = j + DIRECTIONS[k][1];
        if (master.canMove(CHARS[k])) {
            master.move(CHARS[k]);
            dfs(r, c, master, grid);
            // moves back
            master.move(CHARS[(k + 2) % 4]);
        } else {
            grid[r][c] = Cell.BLOCKED;
        }
    }
}
{% endhighlight %}

[clone-graph]: https://leetcode.com/problems/clone-graph/
[keys-and-rooms]: https://leetcode.com/problems/keys-and-rooms/
[lexicographical-numbers]: https://leetcode.com/problems/lexicographical-numbers/
[lexicographically-smallest-string-after-applying-operations]: https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/
[number-of-distinct-islands]: https://leetcode.com/problems/number-of-distinct-islands/
[pyramid-transition-matrix]: https://leetcode.com/problems/pyramid-transition-matrix/
[shortest-path-in-a-hidden-grid]: https://leetcode.com/problems/shortest-path-in-a-hidden-grid/
[the-earliest-and-latest-rounds-where-players-compete]: https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/
[time-needed-to-inform-all-employees]: https://leetcode.com/problems/time-needed-to-inform-all-employees/
