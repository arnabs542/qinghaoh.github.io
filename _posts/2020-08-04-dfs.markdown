---
layout: post
title:  "DFS"
tags: dfs
---
## Template
[Keys and Rooms][keys-and-rooms]

### Recursion

{% highlight java %}
private Set<Integer> set = new HashSet<>();

public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    dfs(rooms, 0);
    return set.size() == rooms.size();
}

private void dfs(List<List<Integer>> rooms, int room) {
    if (set.contains(room)) {
        return;
    }

    set.add(room);
    for (int key : rooms.get(room)) {
        dfs(rooms, key);
    }
}
{% endhighlight %}

### Stack

{% highlight java %}
public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    Set<Integer> set = new HashSet<>();
    set.add(0);

    Deque<Integer> st = new ArrayDeque();
    st.push(0);

    while (!st.isEmpty()) {
        int room = st.pop();
        for (int key: rooms.get(room)) {
            if (!set.contains(key)) {
                set.add(key);
                st.push(key);
            }
        }
    }

    return set.size() == rooms.size();
}
{% endhighlight %}

[Pyramid Transition Matrix][pyramid-transition-matrix]

{% highlight java %}
private Map<String, Set<Character>> map;

public boolean pyramidTransition(String bottom, List<String> allowed) {
    map = new HashMap<>();
    for (String s : allowed) {
        map.computeIfAbsent(s.substring(0, 2), k -> new HashSet<>()).add(s.charAt(2));
    }

    return dfs(bottom, "", 1);
}

private boolean dfs(String row, String nextRow, int index) {
    if (row.length() == 1) {
        return true;
    }

    if (nextRow.length() + 1 == row.length()) {
        return dfs(nextRow, "", 1);
    }

    String key = row.substring(index - 1, index + 1);
    if (map.containsKey(key)) {
        for (Character c : map.get(key)) {
            if (dfs(row, nextRow + c, index + 1)) {
                return true;
            }
        }
    }

    return false;
}
{% endhighlight %}

[keys-and-rooms]: https://leetcode.com/problems/keys-and-rooms/
[pyramid-transition-matrix]: https://leetcode.com/problems/pyramid-transition-matrix/
