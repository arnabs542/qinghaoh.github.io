---
layout: post
title:  "Tree"
tags: tree
---

# Terminology

[Terminology](https://en.wikipedia.org/wiki/Tree_(data_structure))

*height*
  * the length of the longest downward path to a leaf from the node
  * the height of the root is the height of the tree
  * leaf nodes have height zero

*depth*
  * the length of the path from the node to its root (i.e., its root path)
  * the root node has depth zero

# Complete Tree

[Count Complete Tree Nodes][count-complete-tree-nodes]

{% highlight java %}
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }

    TreeNode left = root, right = root;
    int height = 0;
    // computes height, and moves the right pointer under the rightmost leaf
    while (right != null) {
        left = left.left;
        right = right.right;
        height++;
    }

    // if left pointer is also null, then it's a complete tree
    if (left == null) {
        return (1 << height) - 1;
    }

    return 1 + countNodes(root.left) + countNodes(root.right);
}
{% endhighlight %}

Iterative, no recomputation of `h`:

{% highlight java %}
public int countNodes(TreeNode root) {
    int count = 0, h = height(root);
    TreeNode node = root;
    while (node != null) {
        // left subtree is complete, and its height is (h - 1)
        if (height(node.right) == h - 1) {
            count += 1 << h;  // left subtree: 2 ^ h - 1, root: 1
            node = node.right;
        } else {  // right subtree is complete, and its height is (h - 2)
            count += 1 << h - 1;  // right subtree: 2 ^ (h - 1) - 1, root: 1
            node = node.left;
        }
        h--;
    }
    return count;
}

private int height(TreeNode node) {
    // left subtree determines the height
    return node == null ? -1 : 1 + height(node.left);
}
{% endhighlight %}

# Fenwick Tree

[Fenwick tree (Binary indexed tree)](https://en.wikipedia.org/wiki/Fenwick_tree)

A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers.

{% highlight java %}
public class FenwickTree {
    private int[] A;
    private int size;

    public FenwickTree(int size) {
        this.size = size;
        // one-based indexing is assumed
        A = new int[size + 1];
    }

    // Returns the sum from index 1 to i
    // O(log(n))
    public int sum(int i) {
        int sum = 0;
        while (i > 0)  {
            sum += A[i];
            i -= lsb(i);
        }             
        return sum;
    }

    // Adds k to element with index i
    // O(log(n))
    public void add(int i, int k) {
        while (i <= size) {
            A[i] += k;
            i += lsb(i);
        }
    }

    private int lsb(int i) {
        return i & (-i);
    }
}
{% endhighlight %}

[Range Sum Query - Mutable][range-sum-query-mutable]

[Count Number of Teams][count-number-of-teams]

{% highlight java %}
private int MAX_RATING = (int)1e5;

public int numTeams(int[] rating) {
    FenwickTree left = new FenwickTree(MAX_RATING), right = new FenwickTree(MAX_RATING);

    // bucket counting
    // in the beginning, the middle soldier is at -1
    for (int r : rating) {
        right.add(r, 1);
    }

    int count = 0;
    for (int r : rating) {
        right.add(r, -1);
        count += left.sum(r - 1) * (right.sum(MAX_RATING) - right.sum(r));  // ascending
        count += (left.sum(MAX_RATING) - left.sum(r)) * right.sum(r - 1);  // descending
        left.add(r, 1);
    }

    return count;
}
{% endhighlight %}

[Queries on a Permutation With Key][queries-on-a-permutation-with-key]

{% highlight java %}
public int[] processQueries(int[] queries, int m) {
    int n = queries.length;
    FenwickTree ft = new FenwickTree(n + m);
    int[] index = new int[m];

    // fills the last m positions with 1
    // [1...n] is default to 0
    for (int i = 1; i <= m; i++) {
        ft.add(n + i, 1);
        // memorizes index of the current element
        index[i - 1] = n + i;
    }

    int[] result = new int[n];
    for (int i = 0; i < queries.length; i++) {
        int curr = index[queries[i] - 1];
        result[i] = ft.sum(curr) - 1;

        // relocates queries[i] to a position in [1...n] in reverse order
        int next = n - i;
        ft.add(curr, -1);
        ft.add(next, 1);

        // updates the index of queries[i]
        index[queries[i] - 1] = next;
    }
    return result;
}
{% endhighlight %}

# Cartesian Tree

[Cartesian tree](https://en.wikipedia.org/wiki/Cartesian_tree)

Cartesian tree is a binary tree derived from a sequence of numbers; it can be uniquely defined from the properties that it is heap-ordered and that a symmetric (in-order) traversal of the tree returns the original sequence. 

[Maximum Binary Tree][maximum-binary-tree]

{% highlight java %}
public TreeNode constructMaximumBinaryTree(int[] nums) {
    Deque<TreeNode> st = new ArrayDeque<>();
    for (int num : nums) {
        TreeNode node = new TreeNode(num);
        // monotonically decreasing
        while (!st.isEmpty() && st.peek().val < num) {
            node.left = st.pop();
        }
        if (!st.isEmpty()) {
            st.peek().right = node;
        }
        st.push(node);
    }

    return st.isEmpty() ? null : st.removeLast();
}
{% endhighlight %}

[count-complete-tree-nodes]: https://leetcode.com/problems/count-complete-tree-nodes/
[count-number-of-teams]: https://leetcode.com/problems/count-number-of-teams/
[maximum-binary-tree]: https://leetcode.com/problems/maximum-binary-tree/
[queries-on-a-permutation-with-key]: https://leetcode.com/problems/queries-on-a-permutation-with-key/
[range-sum-query-mutable]: https://leetcode.com/problems/range-sum-query-mutable/
