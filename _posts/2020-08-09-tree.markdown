---
layout: post
title:  "Tree"
tags: tree
---
# Fenwick Tree

[Fenwick tree (Binary indexed tree)](https://en.wikipedia.org/wiki/Fenwick_tree)

A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers.

{% highlight java %}
public class FenwickTree {
    private int[] A;
    private int size;

    public FenwickTree(int size) {
        this.size = size;
        // one-based indexing is assumed
        A = new int[size + 1];
    }

    // Returns the sum from index 1 to i
    // O(log(n))
    public int sum(int i) {
        int sum = 0;
        while (i > 0)  {
            sum += A[i];
            i -= lsb(i);
        }             
        return sum;
    }

    // Adds k to element with index i
    // O(log(n))
    public void add(int i, int k) {
        while (i <= size) {
            A[i] += k;
            i += lsb(i);
        }
    }

    private int lsb(int i) {
        return i & (-i);
    }
}
{% endhighlight %}

[Range Sum Query - Mutable][range-sum-query-mutable]

[Count Number of Teams][count-number-of-teams]

{% highlight java %}
private int MAX_RATING = (int)1e5;

public int numTeams(int[] rating) {
    FenwickTree left = new FenwickTree(MAX_RATING), right = new FenwickTree(MAX_RATING);

    // bucket counting
    // in the beginning, the middle soldier is at -1
    for (int r : rating) {
        right.add(r, 1);
    }

    int count = 0;
    for (int r : rating) {
        right.add(r, -1);
        count += left.sum(r - 1) * (right.sum(MAX_RATING) - right.sum(r));  // ascending
        count += (left.sum(MAX_RATING) - left.sum(r)) * right.sum(r - 1);  // descending
        left.add(r, 1);
    }

    return count;
}
{% endhighlight %}

[Queries on a Permutation With Key][queries-on-a-permutation-with-key]

{% highlight java %}
public int[] processQueries(int[] queries, int m) {
    int n = queries.length;
    FenwickTree ft = new FenwickTree(n + m);
    int[] index = new int[m];

    // fills the last m positions with 1
    // [1...n] is default to 0
    for (int i = 1; i <= m; i++) {
        ft.add(n + i, 1);
        // memorizes index of the current element
        index[i - 1] = n + i;
    }

    int[] result = new int[n];
    for (int i = 0; i < queries.length; i++) {
        int curr = index[queries[i] - 1];
        result[i] = ft.sum(curr) - 1;

        // relocates queries[i] to a position in [1...n] in reverse order
        int next = n - i;
        ft.add(curr, -1);
        ft.add(next, 1);

        // updates the index of queries[i]
        index[queries[i] - 1] = next;
    }
    return result;
}
{% endhighlight %}

# Cartesian Tree

[Cartesian tree](https://en.wikipedia.org/wiki/Cartesian_tree)

Cartesian tree is a binary tree derived from a sequence of numbers; it can be uniquely defined from the properties that it is heap-ordered and that a symmetric (in-order) traversal of the tree returns the original sequence. 

[Maximum Binary Tree][maximum-binary-tree]

{% highlight java %}
public TreeNode constructMaximumBinaryTree(int[] nums) {
    Deque<TreeNode> st = new ArrayDeque<>();
    for (int num : nums) {
        TreeNode node = new TreeNode(num);
        // monotonically decreasing
        while (!st.isEmpty() && st.peek().val < num) {
            node.left = st.pop();
        }
        if (!st.isEmpty()) {
            st.peek().right = node;
        }
        st.push(node);
    }

    return st.isEmpty() ? null : st.removeLast();
}
{% endhighlight %}

[count-number-of-teams]: https://leetcode.com/problems/count-number-of-teams/
[maximum-binary-tree]: https://leetcode.com/problems/maximum-binary-tree/
[queries-on-a-permutation-with-key]: https://leetcode.com/problems/queries-on-a-permutation-with-key/
[range-sum-query-mutable]: https://leetcode.com/problems/range-sum-query-mutable/
