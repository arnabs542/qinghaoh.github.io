---
layout: post
title:  "Geometry"
tags: math
usemathjax: true
---
# Theorem

[Triangle area using coordinates](https://en.wikipedia.org/wiki/Triangle#Using_coordinates)

\\[
T={\frac {1}{2}}{\big |}(x_{A}-x_{C})(y_{B}-y_{A})-(x_{A}-x_{B})(y_{C}-y_{A}){\big |}
\\]

[Triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality#Normed_vector_space)

In a normed vector space $$ V $$, one of the defining properties of the norm is the triangle inequality:

\\[\|x+y\|\leq \|x\|+\|y\|\quad \forall \,x,y\in V\\]

[Escape The Ghosts][escape-the-ghosts]

{% highlight java %}
public boolean escapeGhosts(int[][] ghosts, int[] target) {
    // Manhattan distance
    int d = Math.abs(target[0]) + Math.abs(target[1]);
    for (int[] g : ghosts) {
        if (Math.abs(g[0] - target[0]) + Math.abs(g[1] - target[1]) <= d) {
            return false;
        }
    }
    return true;
}
{% endhighlight %}

[Graham scan](https://en.wikipedia.org/wiki/Graham_scan)

For three points \\(P_{1}=(x_{1},y_{1})\\), \\(P_{2}=(x_{2},y_{2}\\) and \\(P_{3}=(x_{3},y_{3})\\), compute the z-coordinate of the cross product of the two vectors \\(\overrightarrow {P_{1}P_{2}}\\) and \\(\overrightarrow {P_{1}P_{3}}\\), which is given by the expression \\((x_{2}-x_{1})(y_{3}-y_{1})-(y_{2}-y_{1})(x_{3}-x_{1})\\).

[Convex Polygon][convex-polygon]

# Overlapping

[Circle and Rectangle Overlapping][circle-and-rectangle-overlapping]

{% highlight java %}
public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {
    // finds the closest point of the rectangle to the center.
    // if the center is in the rectangle, the center itself is the point
    int x = closest(x_center, x1, x2);
    int y = closest(y_center, y1, y2);

    int dx = x_center - x;
    int dy = y_center - y;

    return dx * dx + dy * dy <= radius * radius;
}

private int closest(int value, int min, int max) {
    return Math.max(min, Math.min(max, value));
}
{% endhighlight %}

# Area

[Minimum Area Rectangle][minimum-area-rectangle]

{% highlight java %}
public int minAreaRect(int[][] points) {
    Map<Integer, Set<Integer>> map = new HashMap<>();
    for (int[] p : points) {
        map.computeIfAbsent(p[0], k -> new HashSet<>()).add(p[1]);
    }

    int min = Integer.MAX_VALUE;
    for (int i = 0; i < points.length; i++) {
        for (int j = 0; j < i; j++) {
            int[] p1 = points[i], p2 = points[j];
            // skips same x or y
            if (p1[0] == p2[0] || p1[1] == p2[1]) {
                continue;
            }

            int area = Math.abs(p1[0] - p2[0]) * Math.abs(p1[1] - p2[1]);
            if (area > min) {
                continue;
            }

            // computes diagonal points only
            // confirms the other two points exist in the set
            if (map.get(p1[0]).contains(p2[1]) && map.get(p2[0]).contains(p1[1])) {
                min = area;
            }
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
{% endhighlight %}

[Minimum Area Rectangle II][minimum-area-rectangle-ii]

{% highlight java %}
public int minAreaRect(int[][] points) {
    Map<Integer, Set<Integer>> map = new HashMap<>();
    for (int[] p : points) {
        map.computeIfAbsent(p[0], k -> new HashSet<>()).add(p[1]);
    }

    int min = Integer.MAX_VALUE;
    for (int i = 0; i < points.length; i++) {
        for (int j = 0; j < i; j++) {
            int[] p1 = points[i], p2 = points[j];
            // skips same x or y
            if (p1[0] == p2[0] || p1[1] == p2[1]) {
                continue;
            }

            int area = Math.abs(p1[0] - p2[0]) * Math.abs(p1[1] - p2[1]);
            if (area > min) {
                continue;
            }

            // computes diagonal points only
            // confirms the other two points exist in the set
            if (map.get(p1[0]).contains(p2[1]) && map.get(p2[0]).contains(p1[1])) {
                min = area;
            }
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
{% endhighlight %}

# Dihedral Group

[Dihedral group](https://en.wikipedia.org/wiki/Dihedral_group): the group of symmetries of a regular polygon, which includes rotations and reflections.

[Number of Distinct Islands II][number-of-distinct-islands-ii]

{% highlight java %}
{% raw %}
private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
private static final int[][] TRANSFORMATIONS = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
{% endraw %}
private int[][] grid;
private int m, n;
private boolean[][] visited;

public int numDistinctIslands2(int[][] grid) {
    this.grid = grid;
    this.m = grid.length;
    this.n = grid[0].length;
    this.visited = new boolean[m][n];

    Set<String> islands = new HashSet<>();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1 && !visited[i][j]) {
                List<int[]> cells = new ArrayList<>();
                dfs(i, j, cells);
                islands.add(norm(cells));
            }
        }
    }
    return islands.size();
}

private void dfs(int i, int j, List<int[]> cells) {
    if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == 0 || visited[i][j]) {
        return;
    }

    visited[i][j] = true;
    cells.add(new int[]{i, j});

    for (int[] d : DIRECTIONS) {
        dfs(i + d[0], j + d[1], cells);
    }
}

private String norm(List<int[]>cells) {
    List<String> forms = new ArrayList<>();
    // generates 8 different transformations:
    //  (x, y), (x, -y), (-x, y), (-x, -y)
    //  (y, x), (-y, x), (y, -x), (-y, -x)
    for (int[] t : TRANSFORMATIONS) {
        List<int[]> list1 = new ArrayList<>(), list2 = new ArrayList<>();
        for (int[] c : cells){
            list1.add(new int[]{c[0] * t[0], c[1] * t[1]});
            list2.add(new int[]{c[1] * t[1], c[0] * t[0]});
        }
        forms.add(getKey(list1));
        forms.add(getKey(list2));
    }

    // sorts the keys and uses the first one as the representative
    Collections.sort(forms);
    return forms.get(0);
}

private String getKey(List<int[]> cells) {
    Collections.sort(cells, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);

    StringBuilder sb = new StringBuilder();
    for (int[] c : cells) {
        // (x - x0, y - y0)
        sb.append((c[0] - cells.get(0)[0]) + "#" + (c[1] - cells.get(0)[1]) + "#");
    }
    return sb.toString();
}
{% endhighlight %}

# Manhattan Distance

[Taxicab geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)

Taxicab metric = \\(l_1\\) distance = \\(l_1\\) norm = Manhattan distance

[Maximum of Absolute Value Expression][maximum-of-absolute-value-expression]

{% highlight java %}
public int maxAbsValExpr(int[] arr1, int[] arr2) {
    int max = 0, n = arr1.length;
    int[] coefficients = {-1, 1};

    // |x[i] - x[j]| + |y[i] - y[j]| + |i - j| = f(j) - f(i)
    //   where f(i) = p * x[i] + q * y[i] + i
    //   with p = 1 or -1, q = 1 or -1
    for (int p : coefficients) {
        for (int q : coefficients) {
            // origin point
            int origin = p * arr1[0] + q * arr2[0] + 0;
            // computes the Manhattan distance to the origin point
            for (int i = 1; i < n; ++i) {
                int value = p * arr1[i] + q * arr2[i] + i;
                max = Math.max(max, value - origin);
                origin = Math.min(origin, value);
            }
        }
    }
    return max;
}
{% endhighlight %}

# Circle

## Smallest Circle Problem

[Smallest-circle problem](https://en.wikipedia.org/wiki/Smallest-circle_problem): computing the smallest circle that contains all of a given set of points in the Euclidean plane.

[Circum Circle Cartesian equation](https://en.wikipedia.org/wiki/Circumscribed_circle#Cartesian_coordinates):

Circumcenter:
\\[\frac{\mathbf{S}}{a}\\]

Circumradius:
\\[\sqrt{\frac{b}{a} + \frac{\|\mathbf{S}\|^2}{a ^ 2}}\\]

{% highlight java %}
public double[] outerTrees(int[][] trees) {
    return welzl(trees, new ArrayList<>(), 0);
}

// Welzl's algorithm
private double[] welzl(int[][] p, List<int[]> r, int offset) {
    if (offset == p.length || r.size() == 3) {
        return trivial(r);
    }

    double[] circle = welzl(p, r, offset + 1);

    if (isInside(circle, p[offset])) {
        return circle;
    }

    // backtrack
    r.add(p[offset]);
    circle = welzl(p, r, offset + 1);
    r.remove(r.size() - 1);
    return circle;
}

private double[] trivial(List<int[]> r) {
    if (r.isEmpty()) {
        return null;
    }

    if (r.size() == 1) {
        return new double[] {r.get(0)[0], r.get(0)[1], 0};
    }

    if (r.size() == 2) {
        return computeCircle2(r.get(0), r.get(1));
    }

    // if one angle is obtuse
    // - (r[0], r[1])
    // - (r[0], r[2])
    // - (r[1], r[2])
    for (int i = 0; i < 2; i++) {
        for (int j = i + 1; j < 3; j++) {
            double[] c = computeCircle2(r.get(i), r.get(j));
            if (isInside(c, r.get(3 - i - j))) {
                return c;
            }
        }
    }

    // circumscribed circle
    return computeCircumscribedCircle(r.get(0), r.get(1), r.get(2));
}

// Compute the circle whose diameter is [p1, p2]
private double[] computeCircle2(int[] p1, int[] p2) {
    double x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1];
    double r2 = squaredDistance(p1, p2);
    return new double[] {(x1 + x2) / 2, (y1 + y2) / 2, Math.sqrt(r2) / 2};
}

private double[] computeCircumscribedCircle(int[] p1, int[] p2, int[] p3) {
    int a2 = squaredDistance(p1), b2 = squaredDistance(p2), c2 = squaredDistance(p3);
    {% raw %}
    double sx = 0.5 * det(new double[][]{{a2, p1[1], 1}, {b2, p2[1], 1}, {c2, p3[1], 1}});
    double sy = 0.5 * det(new double[][]{{p1[0], a2, 1}, {p2[0], b2, 1}, {p3[0], c2, 1}});
    double a = det(new double[][]{{p1[0], p1[1], 1}, {p2[0], p2[1], 1}, {p3[0], p3[1], 1}});
    {% endraw %}

    double[] center = new double[]{sx / a, sy / a};
    double r2 = squaredDistance(center, p1);
    return new double[] {center[0], center[1], Math.sqrt(r2)};
}

private boolean isInside(double[] circle, int[] point) {
    if (circle == null) {
        return false;
    }

    return squaredDistance(circle, point) <= circle[2] * circle[2];
}

// Squared Euclidean distance
private int squaredDistance(int[] p1, int[] p2) {
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
}

private int squaredDistance(int[] p) {
    return p[0] * p[0] + p[1] * p[1];
}

private double squaredDistance(double[] p1, int[] p2) {
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
}

// Determinant of 3 x 3 matrix
private double det(double[][] a) {
    double x = (a[1][1] * a[2][2]) - (a[2][1] * a[1][2]);
    double y = (a[1][0] * a[2][2]) - (a[2][0] * a[1][2]);
    double z = (a[1][0] * a[2][1]) - (a[2][0] * a[1][1]);

    return a[0][0] * x - a[0][1] * y + a[0][2] * z;
}
{% endhighlight %}

[circle-and-rectangle-overlapping]: https://leetcode.com/problems/circle-and-rectangle-overlapping/
[convex-polygon]: https://leetcode.com/problems/convex-polygon/
[escape-the-ghosts]: https://leetcode.com/problems/escape-the-ghosts/
[maximum-of-absolute-value-expression]: https://leetcode.com/problems/maximum-of-absolute-value-expression/
[minimum-area-rectangle]: https://leetcode.com/problems/minimum-area-rectangle/
[minimum-area-rectangle-ii]: https://leetcode.com/problems/minimum-area-rectangle-ii/
[number-of-distinct-islands-ii]: https://leetcode.com/problems/number-of-distinct-islands-ii/
