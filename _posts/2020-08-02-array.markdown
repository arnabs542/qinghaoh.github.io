---
layout: post
title:  "Array"
tags: array
---

[Patching Array][patching-array]

{% highlight java %}
public int minPatches(int[] nums, int n) {
    int patches = 0, i = 0;
    // miss is the smallest missing number
    // [1, miss) is already covered
    // initially the range is empty
    long miss = 1;
    while (miss <= n) {
        if (i < nums.length && nums[i] <= miss) {  // miss is covered
            // extends the range to [1, miss + nums[i])
            miss += nums[i++];
        } else {
            // supposes the number to patch is x
            // after patching, [1, miss) and [x, x + miss) are both covered
            // apparently x <= miss
            // so [1, x + miss) is covered
            // to make the range as large as possible, picks x = miss
            miss += miss;
            patches++;
        }
    }
    return patches;
}
{% endhighlight %}

# Brute Force

[Count The Repetitions][count-the-repetitions]

{% highlight java %}
public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
    char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();
    int count1 = 0, count2 = 0, i = 0, j = 0;

    while (count1 < n1) {
        if (array1[i] == array2[j]) {
            if (++j == array2.length) {
                j = 0;
                count2++;
            }
        }
        if (++i == array1.length) {
            i = 0;
            count1++;
        }
    }

    return count2 / n2;
}
{% endhighlight %}

# Buckets

Count each element in an array `int[] a`.

If `0 <= a[i] <= max`, where max is not too big, then we can use `int[] count = new int[max + 1]` as buckets, instead of `Map<Integer, Integer>` 

# Rotation

[First Missing Positive][first-missing-positive]

{% highlight java %}
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k %= n;
    int start = 0, count = 0;
    while (count != n) {
        int index = start, curr = nums[index];
        do {
            index = (index + k) % n;
            int tmp = nums[index];
            nums[index] = curr;
            curr = tmp;
            count++;
        } while (index != start);
        start++;
    }
    return;
}
{% endhighlight %}

[Rotate Array][rotate-array]

![Example](/assets/rotate_array.png)

{% highlight java %}
public void rotate(int[] nums, int k) {
    k %= nums.length;
    int start = 0, count = 0;
    while (count != nums.length) {
        int index = start, curr = nums[index];
        do {
            index = (index + k) % nums.length;
            int tmp = nums[index];
            nums[index] = curr;
            curr = tmp;
            count++;
        } while (index != start);
        start++;
    }
    return;
}
{% endhighlight %}

[Shift 2D Grid][shift-2d-grid]

[Array Nesting][array-nesting]

{% highlight java %}
public int arrayNesting(int[] nums) {
    int max = 0;
    for (int i = 0; i < nums.length; i++) {
        int length = 0, j = i;
        // finds cycles
        while (nums[j] >= 0) {
            int next = nums[j];
            // marks nums[j] as visited
            nums[j] = -1;
            j = next;
            length++;
        }
        max = Math.max(max, length);
    }
    return max;
}
{% endhighlight %}

[Reverse Words in a String II][reverse-words-in-a-string-ii]

{% highlight java %}
public void reverseWords(char[] s) {
    reverse(s, 0, s.length);

    int start = 0, end = 0;
    while (end < s.length) {
        if (s[end] == ' ') {
            reverse(s, start, end);
            start = end + 1;
        }
        end++;
    }
    reverse(s, start, end);
}

private void reverse(char[] s, int start, int end) {
    int i = start, j = end - 1;
    while (i < j) {
        char tmp = s[i];
        s[i++] = s[j];
        s[j--] = tmp;
    }
}
{% endhighlight %}

[Minimum Number of Flips to Make the Binary String Alternating][minimum-number-of-flips-to-make-the-binary-string-alternating]

{% highlight java %}
public int minFlips(String s) {
    int n = s.length();
    // [parity][binary char]
    int[][] count = new int[2][2]; 
    for (int i = 0; i < s.length(); i++) {
        count[i % 2][s.charAt(i) - '0']++;
    }

    // '0' at odd + '1' at even
    // '0' at even + '1' at odd
    int flips = Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]);

    if (n % 2 == 0) {
        // the only two cases are both covered already
        return flips;
    }

    // rotates the String
    // i is the original index of the char currently at the start
    for (int i = 0; i < n; i++) {
        // removes the first char
        // swaps the parity of all the following (n - 1) chars
        // n is odd so (n - 1) is even - they are in pairs
        int[] tmp = count[0];
        count[0] = count[1];
        count[1] = tmp;

        // since n is odd
        count[1][s.charAt(i) - '0']--;  // removes the first char
        count[0][s.charAt(i) - '0']++;  // appends the first char to the end

        flips = Math.min(flips, Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]));
    }
    return flips;
}
{% endhighlight %}

# Distance

[Shortest Distance to a Character][shortest-distance-to-a-character]

{% highlight java %}
public int[] shortestToChar(String s, char c) {
    int n = s.length(), index = -n;
    int[] d = new int[n];
    // c on left
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == c) {
            index = i;
        }
        d[i] = i - index;
    }
    // c on right
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == c) {
            index = i;
        }
        d[i] = Math.min(d[i], Math.abs(index - i));
    }
    return d;
}
{% endhighlight %}

### Pre-computed

[Shortest Distance to Target Color][shortest-distance-to-target-color]

[Max Chunks To Make Sorted II][max-chunks-to-make-sorted-ii]

{% highlight java %}
public int maxChunksToSorted(int[] arr) {
    int n = arr.length;

    int[] minOfRight = new int[n];
    minOfRight[n - 1] = arr[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);
    }

    int chunks = 0, max = 0;
    for (int i = 0; i < n - 1; i++) {
        max = Math.max(max, arr[i]);
        // splits if all elements to the left <= to all elements to the right
        if (max <= minOfRight[i + 1]) {
            chunks++;
        }
    }
    return chunks + 1;
}
{% endhighlight %}

# Swapping

[Swap Adjacent in LR String][swap-adjacent-in-lr-string]

{% highlight java %}
public boolean canTransform(String start, String end) {
    int n = start.length();
    // indexes of 'L' or 'R';
    List<Integer> si = new ArrayList<>(), ei = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        if (start.charAt(i) == 'L' || start.charAt(i) == 'R') {
            si.add(i);
        }
        if (end.charAt(i) == 'L' || end.charAt(i) == 'R') {
            ei.add(i);
        }
    }

    if (si.size() != ei.size()) {
        return false;
    }

    for (int i = 0; i < si.size(); i++) {
        int sIndex = si.get(i), eIndex = ei.get(i);
        char sc = start.charAt(sIndex), ec = end.charAt(eIndex);
        if (sc != ec) {
            return false;
        }

        if (sc == 'L' && sIndex < eIndex) {
            return false;
        }

        if (sc == 'R' && sIndex > eIndex) {
            return false;
        }
    }
    return true;
}
{% endhighlight %}

[Array With Elements Not Equal to Average of Neighbors][array-with-elements-not-equal-to-average-of-neighbors]

{% highlight java %}
public int[] rearrangeArray(int[] nums) {
    int n = nums.length;
    int[] result = Arrays.copyOf(nums, n);
    for (int i = 1; i < n - 1; i++) {
        // increasing or decreasing
        // if we swap if the middle num is an average of its neighbors
        // we will need two passes: left -> right and right -> left
        // e.g. [0, 1, 2, 3, 4, 5]
        if ((result[i - 1] < result[i] && result[i] < result[i + 1]) || (result[i - 1] > result[i] && result[i] > result[i + 1])) {
            swap(result, i, i + 1);
        }
    }
    return result;
}

private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
{% endhighlight %}

# Set

[Longest Consecutive Sequence][longest-consecutive-sequence]

{% highlight java %}
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) {
        set.add(num);
    }

    int length = 0;
    for (int num : set) {
        // only checks for one direction
        if (!set.contains(num - 1)) {
            int next = num + 1;
            while (set.contains(next)) {
                next++;
            }
            length = Math.max(length, next - num);
        }
    }
    return length;
}
{% endhighlight %}

# Division

[Divide Array Into Increasing Sequences][divide-array-into-increasing-sequences]

{% highlight java %}
public boolean canDivideIntoSubsequences(int[] nums, int k) {
    // m = the maximum frequency of any element in the array
    // then number of sequences >= m

    // a valid solution is possible iff m * k <= n
    // e.g. groups[i % m] = nums[i]
    int freq = 1, groups = 1, n = nums.length;
    for (int i = 1; i < nums.length; i++) {
        freq = nums[i - 1] < nums[i] ? 1 : freq + 1;
        // groups = m
        groups = Math.max(groups, freq);
    }
    return nums.length >= k * groups;
}
{% endhighlight %}

# Two Passes

[Candy][candy]

{% highlight java %}
public int candy(int[] ratings) {
    int n = ratings.length;
    int[] candies = new int[n];
    // gives everyone one candy
    Arrays.fill(candies, 1);

    // left -> right
    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }

    int sum = candies[n - 1];
    // right -> left
    for (int i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
        sum += candies[i];
    }
    return sum;
}
{% endhighlight %}

[array-nesting]: https://leetcode.com/problems/array-nesting/
[array-with-elements-not-equal-to-average-of-neighbors]: https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
[candy]: https://leetcode.com/problems/candy/
[count-the-repetitions]: https://leetcode.com/problems/count-the-repetitions/
[divide-array-into-increasing-sequences]: https://leetcode.com/problems/divide-array-into-increasing-sequences/
[first-missing-positive]: https://leetcode.com/problems/first-missing-positive/
[longest-consecutive-sequence]: https://leetcode.com/problems/longest-consecutive-sequence/
[max-chunks-to-make-sorted-ii]: https://leetcode.com/problems/max-chunks-to-make-sorted-ii/
[minimum-number-of-flips-to-make-the-binary-string-alternating]: https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
[patching-array]: https://leetcode.com/problems/patching-array/
[reverse-words-in-a-string-ii]: https://leetcode.com/problems/reverse-words-in-a-string-ii/
[rotate-array]: https://leetcode.com/problems/rotate-array/
[shift-2d-grid]: https://leetcode.com/problems/shift-2d-grid/
[shortest-distance-to-a-character]: https://leetcode.com/problems/shortest-distance-to-a-character/
[shortest-distance-to-target-color]: https://leetcode.com/problems/shortest-distance-to-target-color/
[swap-adjacent-in-lr-string]: https://leetcode.com/problems/swap-adjacent-in-lr-string/
